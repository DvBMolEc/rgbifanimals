# # Read a species list
# sp_list <- read.csv("C:/Daniel/OneDrive - Wageningen University & Research/Documents/Master Thesis GÃ¶teborg/Thesis report/Data/Rasmus_Master_Sheets/UniqueSpeciesBOLDigger_20220511.csv")
# sp_list <- sp_list[, 1]
# sp_list <- as.data.frame(sp_list)
library("dplyr")
# Coordinates <- read.csv("C:/Users/DaniÃ«l van Berkel/OneDrive - WageningenUR/Documents/Master Thesis GÃ¶teborg/Thesis report/MetaData/Overview ARMS locations_compressed.csv")
# Coordinates <- Coordinates %>% select(Observatory.ID, Longitude, Latitude) %>% group_by(Observatory.ID) %>% slice_head()
#enter here the coordinates of the sampling site in wgs84
sampling_location <- structure(c(11.434860, 58.35330), .Dim = 1:2) # Swedish West Coast
# Iterate over the rows of the species list and capture output
starttime = Sys.time()
Distances <- capture.output((for (j in 1:benchmarkaantal){
species <- scan(text = sp_list[j], what = "")
url1 <- paste("https://api.gbif.org/v1/species/match?name=", species[1], "%20", species[2], sep="")
dat <- fromJSON(url1, flatten = TRUE)
# Get species distribution data from GBIF
url2 <- paste("https://api.gbif.org/v1/occurrence/search?speciesKey=",dat$usageKey,"&limit=1000", sep="")
res = fromJSON(url2, flatten = TRUE)
attach(res$results, warn.conflicts = F)
# Skip any species entries that do not exist or do not have any georeferenced entries
if (exists("decimalLongitude")){
detach(res$results)
# Remove occurrences that don't have coordinate information
res$results[, c('decimalLongitude', 'decimalLatitude')]
na <- !is.na(res$results[, 'decimalLongitude'])
notna0 <- res$results[na, ]
notna <- notna0[!duplicated(notna0[, 'decimalLongitude']), ]
# Find closest occurrences by selecting a box around the sampling location with at least 5 occurrences, with a maximum of 20 degrees from the sampling location.
for (k in 1:20) {
close_loc <- notna %>%
filter(between(notna$decimalLongitude, sampling_location[1,1] - k, sampling_location[1,1] + k) &
between(notna$decimalLatitude, sampling_location[1,2] - k, sampling_location[1,2] + k))
if (nrow(close_loc) > 5) {
notna <- close_loc
} else {
NULL
}
}
#Change any entries which are considered to be in the same "box" on the map as the sampling location. (resolution is 0.3, 0.15), as this would yield an error in the shortestPath function.
notna$decimalLatitude <- ifelse(between(notna$decimalLongitude, sampling_location[1,1] - 0.3, sampling_location[1,1] + 0.3) &
between(notna$decimalLatitude, sampling_location[1,2] - 0.15, sampling_location[1,2]),
notna$decimalLatitude - 0.16,
notna$decimalLatitude)
notna$decimalLatitude <- ifelse(between(notna$decimalLongitude, sampling_location[1,1] - 0.3, sampling_location[1,1] + 0.3) &
between(notna$decimalLatitude, sampling_location[1,2], sampling_location[1,2] + 0.15),
notna$decimalLatitude + 0.16,
notna$decimalLatitude)
#If the notna df is build from the close_loc df, take a random sample of maximum 100 samples, to potentially save computing time
#In case there are less than 100 entries, it will yield an error which you can ignore
if(nrow(close_loc) > 1) {
notna <- notna[sample(nrow(notna), 100, replace = F), ]
}
x <- rep("NA", nrow(notna))
# start_time <- Sys.time()
x <- sapply(1:nrow(notna), function(i) {
gbif_occurrence <- structure(c(notna[i, 'decimalLongitude'], notna[i, 'decimalLatitude']), .Dim = 1:2)
path <- shortestPath(tr, sampling_location, gbif_occurrence, output = "SpatialLines")
x[i] <- geosphere::lengthLine(path)
})
d <- min(as.numeric(x), na.rm=T)/1000
# end_time <- Sys.time()
#print(end_time - start_time)
print(paste(d, ",", sp_list[j,]))
}
}
), file = "Distances.csv", append = TRUE, type = "output")
endtime = Sys.time()
print(endtime-starttime)
load("C:/Users/Tim/Desktop/Thesis Daniel/range_expansion_20220521_Tim.RData")
# Iterate over the rows of the species list and capture output
start = Sys.time()
Distances <- capture.output((for (j in 1:10){
species <- scan(text = sp_list[j,], what = "")
url1 <- paste("https://api.gbif.org/v1/species/match?name=", species[1], "%20", species[2], sep="")
dat <- fromJSON(url1, flatten = TRUE)
# Get species distribution data from GBIF
url2 <- paste("https://api.gbif.org/v1/occurrence/search?speciesKey=",dat$usageKey,"&limit=1000", sep="")
res = fromJSON(url2, flatten = TRUE)
attach(res$results, warn.conflicts = F)
# Skip any species entries that do not exist or do not have any georeferenced entries
if (exists("decimalLongitude")){
detach(res$results)
# Remove occurrences that don't have coordinate information
res$results[, c('decimalLongitude', 'decimalLatitude')]
na <- !is.na(res$results[, 'decimalLongitude'])
notna0 <- res$results[na, ]
notna <- notna0[!duplicated(notna0[, 'decimalLongitude']), ]
# Find closest occurrences by selecting a box around the sampling location with at least 5 occurrences, with a maximum of 20 degrees from the sampling location.
for (k in 1:20) {
close_loc <- notna %>%
filter(between(notna$decimalLongitude, sampling_location[1, 1] - k, sampling_location[1, 1] + k) &
between(notna$decimalLatitude, sampling_location[1, 2] - k, sampling_location[1, 2] + k))
if (nrow(close_loc) > 5) {
notna <- close_loc
} else {
NULL
}
}
#Change any entries which are considered to be in the same "box" on the map as the sampling location. (resolution is 0.3, 0.15), as this would yield an error in the shortestPath function.
notna$decimalLatitude <- ifelse(between(notna$decimalLongitude, sampling_location[1, 1] - 0.3, sampling_location[1, 1] + 0.3) &
between(notna$decimalLatitude, sampling_location[1, 2] - 0.15, sampling_location[1, 2]),
notna$decimalLatitude - 0.16,
notna$decimalLatitude)
notna$decimalLatitude <- ifelse(between(notna$decimalLongitude, sampling_location[1, 1] - 0.3, sampling_location[1, 1] + 0.3) &
between(notna$decimalLatitude, sampling_location[1, 2], sampling_location[1, 2] + 0.15),
notna$decimalLatitude + 0.16,
notna$decimalLatitude)
#If the notna df is build from the close_loc df, take a random sample of maximum 100 samples, to potentially save computing time
#In case there are less than 100 entries, it will yield an error which you can ignore
if(nrow(close_loc) > 1) {
notna <- notna[sample(nrow(notna), 100, replace = F), ]
}
x <- rep("NA", nrow(notna))
start_time <- Sys.time()
x <- sapply(1:nrow(notna), function(i) {
gbif_occurrence <- structure(c(notna[i, 'decimalLongitude'], notna[i, 'decimalLatitude']), .Dim = 1:2)
path <- shortestPath(tr, sampling_location, gbif_occurrence, output = "SpatialLines")
x[i] <- geosphere::lengthLine(path)
})
d <- min(as.numeric(x), na.rm=T)/1000
end_time <- Sys.time()
#print(end_time - start_time)
print(paste(d, ",", sp_list[j,]))
}
}
), file = "Distances.csv", append = TRUE, type = "output")
# Set working directory to directory where the R-script is saved
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # requires installation of package "rstudioapi"
# Load a map
data(wrld_simpl) #use wrld_simpl from the maptools package
# Generate a scaffold for the raster file
world_crs <- crs(wrld_simpl)
world <- wrld_simpl
worldshp <- spTransform(world, world_crs)
ras <- raster(nrow=1200, ncol=1200)
# Generate a raster file
worldmask <- rasterize(worldshp, ras)
worldras <- is.na(worldmask) # inverse water and land, so ocean becomes 1 and land 0
worldras[worldras==0] <- 999 # set land to 999
# Create a Transition object from the raster
tr <- transition(worldras, function(x) 1/mean(x), 16)
tr = geoCorrection(tr, scl=FALSE)
library("dplyr")
#enter here the coordinates of the sampling site in wgs84
sampling_location <- structure(c(11.434860, 58.35330), .Dim = 1:2) # Swedish West Coast
# Iterate over the rows of the species list and capture output
start = Sys.time()
Distances <- capture.output((for (j in 1:10){
species <- scan(text = sp_list[j,], what = "")
url1 <- paste("https://api.gbif.org/v1/species/match?name=", species[1], "%20", species[2], sep="")
dat <- fromJSON(url1, flatten = TRUE)
# Get species distribution data from GBIF
url2 <- paste("https://api.gbif.org/v1/occurrence/search?speciesKey=",dat$usageKey,"&limit=1000", sep="")
res = fromJSON(url2, flatten = TRUE)
attach(res$results, warn.conflicts = F)
# Skip any species entries that do not exist or do not have any georeferenced entries
if (exists("decimalLongitude")){
detach(res$results)
# Remove occurrences that don't have coordinate information
res$results[, c('decimalLongitude', 'decimalLatitude')]
na <- !is.na(res$results[, 'decimalLongitude'])
notna0 <- res$results[na, ]
notna <- notna0[!duplicated(notna0[, 'decimalLongitude']), ]
# Find closest occurrences by selecting a box around the sampling location with at least 5 occurrences, with a maximum of 20 degrees from the sampling location.
for (k in 1:20) {
close_loc <- notna %>%
filter(between(notna$decimalLongitude, sampling_location[1, 1] - k, sampling_location[1, 1] + k) &
between(notna$decimalLatitude, sampling_location[1, 2] - k, sampling_location[1, 2] + k))
if (nrow(close_loc) > 5) {
notna <- close_loc
} else {
NULL
}
}
#Change any entries which are considered to be in the same "box" on the map as the sampling location. (resolution is 0.3, 0.15), as this would yield an error in the shortestPath function.
notna$decimalLatitude <- ifelse(between(notna$decimalLongitude, sampling_location[1, 1] - 0.3, sampling_location[1, 1] + 0.3) &
between(notna$decimalLatitude, sampling_location[1, 2] - 0.15, sampling_location[1, 2]),
notna$decimalLatitude - 0.16,
notna$decimalLatitude)
notna$decimalLatitude <- ifelse(between(notna$decimalLongitude, sampling_location[1, 1] - 0.3, sampling_location[1, 1] + 0.3) &
between(notna$decimalLatitude, sampling_location[1, 2], sampling_location[1, 2] + 0.15),
notna$decimalLatitude + 0.16,
notna$decimalLatitude)
#If the notna df is build from the close_loc df, take a random sample of maximum 100 samples, to potentially save computing time
#In case there are less than 100 entries, it will yield an error which you can ignore
if(nrow(close_loc) > 1) {
notna <- notna[sample(nrow(notna), 100, replace = F), ]
}
x <- rep("NA", nrow(notna))
start_time <- Sys.time()
x <- sapply(1:nrow(notna), function(i) {
gbif_occurrence <- structure(c(notna[i, 'decimalLongitude'], notna[i, 'decimalLatitude']), .Dim = 1:2)
path <- shortestPath(tr, sampling_location, gbif_occurrence, output = "SpatialLines")
x[i] <- geosphere::lengthLine(path)
})
d <- min(as.numeric(x), na.rm=T)/1000
end_time <- Sys.time()
#print(end_time - start_time)
print(paste(d, ",", sp_list[j,]))
}
}
), file = "Distances.csv", append = TRUE, type = "output")
end = Sys.time()
print(end-start)
# Iterate over the rows of the species list and capture output
start = Sys.time()
Distances <- capture.output((for (j in 1:10){
species <- scan(text = sp_list[j,], what = "")
url1 <- paste("https://api.gbif.org/v1/species/match?name=", species[1], "%20", species[2], sep="")
dat <- fromJSON(url1, flatten = TRUE)
# Get species distribution data from GBIF
url2 <- paste("https://api.gbif.org/v1/occurrence/search?speciesKey=",dat$usageKey,"&limit=1000", sep="")
res = fromJSON(url2, flatten = TRUE)
attach(res$results, warn.conflicts = F)
# Skip any species entries that do not exist or do not have any georeferenced entries
if (exists("decimalLongitude")){
detach(res$results)
# Remove occurrences that don't have coordinate information
res$results[, c('decimalLongitude', 'decimalLatitude')]
na <- !is.na(res$results[, 'decimalLongitude'])
notna0 <- res$results[na, ]
notna <- notna0[!duplicated(notna0[, 'decimalLongitude']), ]
# Find closest occurrences by selecting a box around the sampling location with at least 5 occurrences, with a maximum of 20 degrees from the sampling location.
for (k in 1:20) {
close_loc <- notna %>%
filter(between(notna$decimalLongitude, sampling_location[1, 1] - k, sampling_location[1, 1] + k) &
between(notna$decimalLatitude, sampling_location[1, 2] - k, sampling_location[1, 2] + k))
if (nrow(close_loc) > 5) {
notna <- close_loc
} else {
NULL
}
}
#Change any entries which are considered to be in the same "box" on the map as the sampling location. (resolution is 0.3, 0.15), as this would yield an error in the shortestPath function.
notna$decimalLatitude <- ifelse(between(notna$decimalLongitude, sampling_location[1, 1] - 0.3, sampling_location[1, 1] + 0.3) &
between(notna$decimalLatitude, sampling_location[1, 2] - 0.15, sampling_location[1, 2]),
notna$decimalLatitude - 0.16,
notna$decimalLatitude)
notna$decimalLatitude <- ifelse(between(notna$decimalLongitude, sampling_location[1, 1] - 0.3, sampling_location[1, 1] + 0.3) &
between(notna$decimalLatitude, sampling_location[1, 2], sampling_location[1, 2] + 0.15),
notna$decimalLatitude + 0.16,
notna$decimalLatitude)
#If the notna df is build from the close_loc df, take a random sample of maximum 100 samples, to potentially save computing time
#In case there are less than 100 entries, it will yield an error which you can ignore
if(nrow(close_loc) > 100) {
notna <- notna[sample(nrow(notna), 100, replace = F), ]
}
x <- rep("NA", nrow(notna))
start_time <- Sys.time()
x <- sapply(1:nrow(notna), function(i) {
gbif_occurrence <- structure(c(notna[i, 'decimalLongitude'], notna[i, 'decimalLatitude']), .Dim = 1:2)
path <- shortestPath(tr, sampling_location, gbif_occurrence, output = "SpatialLines")
x[i] <- geosphere::lengthLine(path)
})
d <- min(as.numeric(x), na.rm=T)/1000
end_time <- Sys.time()
#print(end_time - start_time)
print(paste(d, ",", sp_list[j,]))
}
}
), file = "Distances.csv", append = TRUE, type = "output")
end = Sys.time()
print(end-start)
# Set working directory to directory where the R-script is saved
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # requires installation of package "rstudioapi"
#Create a rastered world
tr <- create_rastered_world()
create_rastered_world <- function(){
# Load a map
data(wrld_simpl) #use wrld_simpl from the maptools package
# Generate a scaffold for the raster file
world_crs <- crs(wrld_simpl)
worldshp <- spTransform(wrld_simpl, world_crs)
ras <- raster(nrow=1200, ncol=1200)
# Generate a raster file
worldmask <- rasterize(worldshp, ras)
worldras <- is.na(worldmask) # inverse water and land, so ocean becomes 1 and land 0
worldras[worldras==0] <- 999 # set land to 999
# Create a Transition object from the raster
tr <- transition(worldras, function(x) 1/mean(x), 16)
tr <- geoCorrection(tr, scl=FALSE)
return(tr)
}
find_closest_registered_place <- function(species, startpoint, tr, outputfile){
gbif <- occ_data(scientificName = species, hasCoordinate = TRUE, limit = 1000)
res <- gbif$data
# Remove duplicate coordinates
res <- res[!duplicated(res),]
# Add column with distance
res$distance <- pmax(abs(res$decimalLongitude - startpoint[1]),
abs(res$decimalLatitude - startpoint[2]))
# Get the 5th smallest distance and round it up
dist = ceiling(sort(res$distance)[5])
res <- res[res$distance < dist,]
if(nrow(res) < 5){
write.table(paste(species, "", "There are no 5 geo locations in GBIF", sep = ","), file = outputfile, append = TRUE,
quote = FALSE, col.names = FALSE, row.names = FALSE)
return()
}
# I'm not completely sure about this part of the code. I think the bug should be fixed not avoided :(
#Change any entries which are considered to be in the same "box" on the map as the sampling location. (resolution is 0.3, 0.15), as this would yield an error in the shortestPath function.
res$decimalLatitude <- ifelse(between(res$decimalLongitude, startpoint[1] - 0.3, startpoint[1] + 0.3) &
between(res$decimalLatitude, startpoint[2] - 0.15, startpoint[2]),
res$decimalLatitude - 0.16,
res$decimalLatitude)
res$decimalLatitude <- ifelse(between(res$decimalLongitude, startpoint[1] - 0.3, startpoint[1] + 0.3) &
between(res$decimalLatitude, startpoint[2], startpoint[2] + 0.15),
res$decimalLatitude + 0.16,
res$decimalLatitude)
# I don't see why we do this, but okay
x <- rep("NA", nrow(res))
# find the shortest route to every point through the sea
x <- sapply(1:nrow(res), function(i) {
gbif_occurrence <- structure(c(res$decimalLongitude[i], res$decimalLatitude[i]), .Dim = 1:2)
path <- shortestPath(tr, structure(startpoint, .Dim = 1:2), gbif_occurrence, output = "SpatialLines")
x[i] <- geosphere::lengthLine(path)
})
# Find the closest location the point of sampling
d <- min(as.numeric(x), na.rm=T)/1000
#prepare output for writing to file
write.table(paste(species, d, " ",  sep = ","), file = outputfile, append = TRUE,
quote = FALSE, col.names = FALSE, row.names = FALSE)
}
# Set working directory to directory where the R-script is saved
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # requires installation of package "rstudioapi"
#Create a rastered world
tr <- create_rastered_world()
ter")
library("gdistance")
library("maptools")
library("dplyr")
# library("rgdal")
library("jsonlite")
# require("geosphere")
# require("curl")
require("rgbif")
# library("maps")
library("ggplot2")
#Create a rastered world
tr <- create_rastered_world()
#Create a rastered world
tr <- create_rastered_world()
# Load packages
#library("raster")
library("gdistance")
library("maptools")
library("dplyr")
# library("rgdal")
library("jsonlite")
# require("geosphere")
# require("curl")
require("rgbif")
# library("maps")
library("ggplot2")
create_rastered_world <- function(){
# Load a map
data(wrld_simpl) #use wrld_simpl from the maptools package
# Generate a scaffold for the raster file
world_crs <- crs(wrld_simpl)
worldshp <- spTransform(wrld_simpl, world_crs)
ras <- raster(nrow=1200, ncol=1200)
# Generate a raster file
worldmask <- rasterize(worldshp, ras)
worldras <- is.na(worldmask) # inverse water and land, so ocean becomes 1 and land 0
worldras[worldras==0] <- 999 # set land to 999
# Create a Transition object from the raster
tr <- transition(worldras, function(x) 1/mean(x), 16)
tr <- geoCorrection(tr, scl=FALSE)
return(tr)
}
find_closest_registered_place <- function(species, startpoint, tr, outputfile){
gbif <- occ_data(scientificName = species, hasCoordinate = TRUE, limit = 1000)
res <- gbif$data
# Remove duplicate coordinates
res <- res[!duplicated(res),]
# Add column with distance
res$distance <- pmax(abs(res$decimalLongitude - startpoint[1]),
abs(res$decimalLatitude - startpoint[2]))
# Get the 5th smallest distance and round it up
dist = ceiling(sort(res$distance)[5])
res <- res[res$distance < dist,]
if(nrow(res) < 5){
write.table(paste(species, "", "There are no 5 geo locations in GBIF", sep = ","), file = outputfile, append = TRUE,
quote = FALSE, col.names = FALSE, row.names = FALSE)
return()
}
# I'm not completely sure about this part of the code. I think the bug should be fixed not avoided :(
#Change any entries which are considered to be in the same "box" on the map as the sampling location. (resolution is 0.3, 0.15), as this would yield an error in the shortestPath function.
res$decimalLatitude <- ifelse(between(res$decimalLongitude, startpoint[1] - 0.3, startpoint[1] + 0.3) &
between(res$decimalLatitude, startpoint[2] - 0.15, startpoint[2]),
res$decimalLatitude - 0.16,
res$decimalLatitude)
res$decimalLatitude <- ifelse(between(res$decimalLongitude, startpoint[1] - 0.3, startpoint[1] + 0.3) &
between(res$decimalLatitude, startpoint[2], startpoint[2] + 0.15),
res$decimalLatitude + 0.16,
res$decimalLatitude)
# I don't see why we do this, but okay
x <- rep("NA", nrow(res))
# find the shortest route to every point through the sea
x <- sapply(1:nrow(res), function(i) {
gbif_occurrence <- structure(c(res$decimalLongitude[i], res$decimalLatitude[i]), .Dim = 1:2)
path <- shortestPath(tr, structure(startpoint, .Dim = 1:2), gbif_occurrence, output = "SpatialLines")
x[i] <- geosphere::lengthLine(path)
})
# Find the closest location the point of sampling
d <- min(as.numeric(x), na.rm=T)/1000
#prepare output for writing to file
write.table(paste(species, d, " ",  sep = ","), file = outputfile, append = TRUE,
quote = FALSE, col.names = FALSE, row.names = FALSE)
}
# Set working directory to directory where the R-script is saved
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # requires installation of package "rstudioapi"
#Create a rastered world
tr <- create_rastered_world()
# Read a species list
sp_list <- read.csv("sp_list.csv")
sp_list <- as.character(sp_list[,2])
# Read coordinates file
Coordinates <- read.csv("Coordinates.csv")
#enter here the coordinates of the sampling site in wgs84
startpoint <- structure(c(11.434860, 58.35330)) # Swedish West Coast
species = sp_list[50]
gbif <- occ_data(scientificName = species, hasCoordinate = TRUE, limit = 1000)
res = gbif$data
View(res)
gbif <- occ_data(scientificName = species, hasCoordinate = TRUE, limit = 10000)
res = gbif$data
species = sp_list[50]
gbif <- occ_data(scientificName = species, hasCoordinate = TRUE, limit = 100000)
res = gbif$data
starttime = Sys.time()
species = sp_list[50]
gbif <- occ_data(scientificName = species, hasCoordinate = TRUE, limit = 100000)
res = gbif$data
endtime = Sys.time()
print(endtime-starttime)
starttime = Sys.time()
species = sp_list[50]
gbif <- occ_data(scientificName = species, hasCoordinate = TRUE, limit = 1000)
res = gbif$data
endtime = Sys.time()
print(endtime-starttime)
starttime = Sys.time()
species = sp_list[50]
gbif <- occ_data(scientificName = species, hasCoordinate = TRUE, limit = 10000)
res = gbif$data
endtime = Sys.time()
print(endtime-starttime)
starttime = Sys.time()
species = sp_list[50]
gbif <- occ_data(scientificName = species, hasCoordinate = TRUE, limit = 51984)
res = gbif$data
endtime = Sys.time()
print(endtime-starttime)
sapply(sp_list, function(species){
starttime = Sys.time()
gbif <- occ_data(scientificName = species, hasCoordinate = TRUE, limit = 10000)
res = gbif$data
endtime = Sys.time()
return(gbif$meta$count)
})
test <- sapply(sp_list[1:4], function(species){
starttime = Sys.time()
gbif <- occ_data(scientificName = species, hasCoordinate = TRUE, limit = 10)
res = gbif$data
endtime = Sys.time()
return(gbif$meta$count)
})
test <- sapply(sp_list, function(species){
starttime = Sys.time()
gbif <- occ_data(scientificName = species, hasCoordinate = TRUE, limit = 10)
res = gbif$data
endtime = Sys.time()
return(gbif$meta$count)
})
starttime = Sys.time()
test <- sapply(sp_list, function(species){
gbif <- occ_data(scientificName = species, hasCoordinate = TRUE, limit = 10)
res = gbif$data
return(gbif$meta$count)
})
endtime = Sys.time()
print(endtime - starttime)
mean(test)
plot(dist(test))
plot(test)
ggplot(test) + geom_density()
ggplot(df(test)) + geom_density()
ggplot(data.frame(test)) + geom_density()
data.frame(test)
ggplot(data.frame(test)) + geom_density(aes(x=test))
length(test)
sum(test<50000)
sum(test<5000)
sum(test<50000)
sum(test < 100000)
sp_list[which(test > 100000)]
starttime = Sys.time()
test <- sapply(sp_list, function(species){
gbif <- occ_data(scientificName = species, hasCoordinate = TRUE, limit = 10)
res = gbif$data
return(gbif$meta$count)
})
endtime = Sys.time()
print(endtime - starttime)
?occ_data
?occ_count
test <- sapply(sp_list, function(species){
gbif <- occ_count(scientificName = species, hasCoordinate = TRUE)
res = gbif$data
return(gbif$meta$count)
})
